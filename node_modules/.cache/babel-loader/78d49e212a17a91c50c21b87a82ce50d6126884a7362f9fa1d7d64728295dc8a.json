{"ast":null,"code":"import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, normalizeStyle as _normalizeStyle } from \"vue\";\nconst _hoisted_1 = [\"task\"];\nconst _hoisted_2 = [\"task\", \"d\"];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"svg\", {\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    class: \"gantt-elastic__chart-dependency-lines-container\",\n    style: _normalizeStyle({\n      ...$options.root.style['chart-dependency-lines-container']\n    })\n  }, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList($options.dependencyTasks, task => {\n    return _openBlock(), _createElementBlock(\"g\", {\n      key: task.id,\n      task: task\n    }, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList(task.dependencyLines, dependencyLine => {\n      return _openBlock(), _createElementBlock(\"path\", {\n        class: \"gantt-elastic__chart-dependency-lines-path\",\n        style: _normalizeStyle({\n          ...$options.root.style['chart-dependency-lines-path'],\n          ...task.style['chart-dependency-lines-path'],\n          ...task.style['chart-dependency-lines-path-' + dependencyLine.task_id]\n        }),\n        key: dependencyLine.id,\n        task: task,\n        d: dependencyLine.points\n      }, null, 12 /* STYLE, PROPS */, _hoisted_2);\n    }), 128 /* KEYED_FRAGMENT */))], 8 /* PROPS */, _hoisted_1);\n  }), 128 /* KEYED_FRAGMENT */))], 4 /* STYLE */);\n}","map":{"version":3,"names":["_createElementBlock","x","y","width","height","class","style","_normalizeStyle","$options","root","_Fragment","_renderList","dependencyTasks","task","key","id","dependencyLines","dependencyLine","task_id","d","points","_hoisted_2","_hoisted_1"],"sources":["/var/www/vue/vue-gantt-chart/node_modules/gantt-elastic/src/components/Chart/DependencyLines.vue"],"sourcesContent":["<!--\n/**\n * @fileoverview DependencyLines component\n * @license MIT\n * @author Rafal Pospiech <neuronet.io@gmail.com>\n * @package GanttElastic\n */\n-->\n<template>\n  <svg\n    x=\"0\"\n    y=\"0\"\n    width=\"100%\"\n    height=\"100%\"\n    class=\"gantt-elastic__chart-dependency-lines-container\"\n    :style=\"{ ...root.style['chart-dependency-lines-container'] }\"\n  >\n    <g v-for=\"task in dependencyTasks\" :key=\"task.id\" :task=\"task\">\n      <path\n        class=\"gantt-elastic__chart-dependency-lines-path\"\n        :style=\"{ ...root.style['chart-dependency-lines-path'], ...task.style['chart-dependency-lines-path'], ...task.style['chart-dependency-lines-path-' + dependencyLine.task_id] }\"\n        v-for=\"dependencyLine in task.dependencyLines\"\n        :key=\"dependencyLine.id\"\n        :task=\"task\"\n        :d=\"dependencyLine.points\"\n      ></path>\n    </g>\n  </svg>\n</template>\n\n<script>\nexport default {\n  name: 'DependencyLines',\n  inject: ['root'],\n  props: ['tasks'],\n  data() {\n    return {};\n  },\n  methods: {\n    /**\n     * Get path points\n     *\n     * @param {any} fromTaskId\n     * @param {any} toTaskId\n     * @returns {string}\n     */\n    getPoints(fromTaskId, toTaskId) {\n      const fromTask = this.root.getTask(fromTaskId);\n      const toTask = this.root.getTask(toTaskId);\n      if (\n        fromTask === null ||\n        toTask === null ||\n        !this.root.isTaskVisible(toTask) ||\n        !this.root.isTaskVisible(fromTask)\n      ) {\n        return null;\n      }\n      const startX = fromTask.x + fromTask.width;\n      const startY = fromTask.y + fromTask.height / 2;\n      const stopX = toTask.x;\n      const stopY = toTask.y + toTask.height / 2;\n      const distanceX = stopX - startX;\n      let distanceY;\n      let yMultiplier = 1;\n      if (stopY >= startY) {\n        distanceY = stopY - startY;\n      } else {\n        distanceY = startY - stopY;\n        yMultiplier = -1;\n      }\n      const offset = 10;\n      const roundness = 4;\n      const isBefore = distanceX <= offset + roundness;\n      let points = `M ${startX} ${startY}\n          L ${startX + offset},${startY} `;\n      if (isBefore) {\n        points += `Q ${startX + offset + roundness},${startY} ${startX + offset + roundness},${startY +\n          roundness * yMultiplier}\n            L ${startX + offset + roundness},${startY + (distanceY * yMultiplier) / 2 - roundness * yMultiplier}\n            Q ${startX + offset + roundness},${startY + (distanceY * yMultiplier) / 2} ${startX + offset},${startY +\n          (distanceY * yMultiplier) / 2}\n            L ${startX - offset + distanceX},${startY + (distanceY * yMultiplier) / 2}\n            Q ${startX - offset + distanceX - roundness},${startY + (distanceY * yMultiplier) / 2} ${startX -\n          offset +\n          distanceX -\n          roundness},${startY + (distanceY * yMultiplier) / 2 + roundness * yMultiplier}\n            L ${startX - offset + distanceX - roundness},${stopY - roundness * yMultiplier}\n            Q ${startX - offset + distanceX - roundness},${stopY} ${startX - offset + distanceX},${stopY}\n            L ${stopX},${stopY}`;\n      } else {\n        points += `L ${startX + distanceX / 2 - roundness},${startY}\n            Q ${startX + distanceX / 2},${startY} ${startX + distanceX / 2},${startY + roundness * yMultiplier}\n            L ${startX + distanceX / 2},${stopY - roundness * yMultiplier}\n            Q ${startX + distanceX / 2},${stopY} ${startX + distanceX / 2 + roundness},${stopY}\n            L ${stopX},${stopY}`;\n      }\n      return points;\n    }\n  },\n  computed: {\n    /**\n     * Get tasks which are dependent on other tasks\n     *\n     * @returns {array}\n     */\n    dependencyTasks() {\n      return this.tasks\n        .filter(task => typeof task.dependentOn !== 'undefined')\n        .map(task => {\n          task.dependencyLines = task.dependentOn.map(id => {\n            return { points: this.getPoints(id, task.id), task_id: id };\n          });\n          return task;\n        })\n        .filter(task => task.dependencyLines.points !== null);\n    }\n  }\n};\n</script>\n"],"mappings":";mBAAA;mBAAA;;uBASEA,mBAAA,CAkBM;IAjBJC,CAAC,EAAC,GAAG;IACLC,CAAC,EAAC,GAAG;IACLC,KAAK,EAAC,MAAM;IACZC,MAAM,EAAC,MAAM;IACbC,KAAK,EAAC,iDAAiD;IACtDC,KAAK,EAfVC,eAAA;MAAA,GAeiBC,QAAA,CAAAC,IAAI,CAACH,KAAK;IAAA;yBAEvBN,mBAAA,CASIU,SAAA,QA1BRC,WAAA,CAiBsBH,QAAA,CAAAI,eAAe,EAAvBC,IAAI;yBAAdb,mBAAA,CASI;MATgCc,GAAG,EAAED,IAAI,CAACE,EAAE;MAAGF,IAAI,EAAEA;2BACvDb,mBAAA,CAOQU,SAAA,QAzBdC,WAAA,CAqBiCE,IAAI,CAACG,eAAe,EAAtCC,cAAc;2BAHvBjB,mBAAA,CAOQ;QANNK,KAAK,EAAC,4CAA4C;QACjDC,KAAK,EApBdC,eAAA;UAAA,GAoBqBC,QAAA,CAAAC,IAAI,CAACH,KAAK;UAAA,GAAoCO,IAAI,CAACP,KAAK;UAAA,GAAoCO,IAAI,CAACP,KAAK,kCAAkCW,cAAc,CAACC,OAAO;QAAA;QAE1KJ,GAAG,EAAEG,cAAc,CAACF,EAAE;QACtBF,IAAI,EAAEA,IAAI;QACVM,CAAC,EAAEF,cAAc,CAACG;sCAxB3BC,UAAA;oDAAAC,UAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}